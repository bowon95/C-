#include <iostream>

int main()
{

/*
비트단위 논리연산자 / 쉬프트연산자

우선 진법개념부터 알아야 함.

10진수 : 0 ~ 9 사이의 숫자를 조합하여 사용한다.
2진수 : 0 ~ 1 사이의 숫자를 조합하여 사용한다. (b를 앞에 붙임)
 ex. b1010101
8진수 : 0 ~ 7사이의 숫자를 조합하여 사용한다. (거의 안 쓰임)
16진수 : 0 ~ 15 사이의 숫자를 조합하여 사용한다. (표기 : 0x 를 앞에 붙임)
 0 ~ 9 는 일반 숫자를 사용하고 10 ~ 15 사이는 알파벳 a ~ f 로 사용.
 11은 이진수 16진수 1이 두자리수인 건지, 11인지 구분하기 어렵기 때문.
 10 : a, 11 : b, 12 : c , 13 : d, 14 : e, 15 :f
 ex. 0x11 (16진수가 2자리)
     0xb (16진수의 11)
 
 진수끼리의 변환 : 2진수가 중간 매개체. 10진수 - 2진수 - 16진수 / 16진수 - 2진수 - 10진수
 
 Q. 10진수 123을 2진수와 16진수로 변환.
  10진수 - > 2진수 : 10진수를 2로 계속 나누어서 몫과 나머지를 구한 후, 
                     밑의 몫부터 나머지로 올라가면서 읽기. (더이상 2로 나눌 수 없을 때까지 나눔)
                     변환된 2진법에서 1의 부분의 자릿수 값을 더하기.
 123 / 2 = 61 --- 1
 61 / 2 = 30 ---- 1
 30 / 2 = 15 ---- 0
 15 / 2 = 7 ----- 1
 7 / 2 = 3 ------ 1
 3 / 2 = 1 ------ 1
 
 1  1  1  1  0  1   1
 64 32 16 8  4  2   1 
      = 123
 64 + 32 + 16 + 8 + 2 + 1 = 123
 
 2진수 -> 16진수 : 2진수를 4자리씩 분리. 4자리씩 끊어서 1의 부분의 자릿수 값을 더하기.
 16진수 1자리는 2진수 4자리로 구성된다.
 2진수의 가장 오른쪽부터 4자리씩 분리한다.     =>  111 1011
 왼쪽 부분의 자릿수가 부족하다면 0을 채워준다. => 0111 1011
 
 0 1 1 1    1 0 1 1
 8 4 2 1    8 4 2 1
  = 7        = 11
 0x7b 
 
 16진수 -> 2진수 : 16진수를 10진수로 바꿔서 연산.
 
 7 / 2 = 3 --- 1
 3 / 2 = 1 --- 1
 
 0111
 
 11 / 2 = 5 --- 1
 5 / 2 = 2 ---- 1
 2 / 2 = 1 ---- 1
 
 1111
 
 즉 0111 1011 이 된다.
*/

 /* 
 비트단위 논리연산자와 쉬프트 연산자는 이진수 단위로 연산을 한다. 
 즉, 일반적인 사칙연산보다 속도가 빠르다. 
 
 비트단위 논리연산자 : AND(&), NOT(~), XOR(^) 또는 exlusive OR.
 
 A  B XOR(다르면 1, 같으면 0)
 0  0  0
 1  0  1
 0  1  1
 1  1  0
 
 123 & 99 
   1111011
 & 1100011
 = 1100011
 
   1111011
 | 1100011
 = 1111011
 
 ~ 123 (보통 int 타입의 정수로 인식되어 32비트)
 00000000 00000000 00000000 01111011
 11111111 11111111 11111111 10000100
 
 123 ^ 99 = 24
   1111011
 ^ 1100011
 = 0011000
 */
 
 std::cout << "123 & 99 = " << (123 & 99) << std::endl; //99
 std::cout << "123 | 99 = " << (123 | 99) << std:endl; //123
 std::cout << "~123 = " << ~123 << std::endl; // -124
 std::cout << "123 ^ 99 = " << (123 ^ 99) << std::endl; // 24
 
 return 0;
 }
 
 
