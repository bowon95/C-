#include <iostream>

int main()
{
 // 비트단위 논리연산자는 플래그(= 상태)를 체크 할 때 사용됨.
 
 /* 
 비트단위로 쪼개서 사용하기.
 bool 타입은 1byte, 8bits다. 
 int 타입은 32비트이며 32가지의 상태를 저장할 수 있다. 
 (1비트씩, 0은 꺼졌다, 1은 켜졌다.) 플래그는 보통 16진수를 사용한다. 
 16진수 한 자리는 네 자리의 이진수와 같다.
 그런데 32가지의 상태를 저장하려면 bool 타입으로 참/거짓을 32번 해야한다.
 이런 비효율을 피하기 위해 int 타입 각각의 비트를 쪼개서 상태를 저장한다.
 심지어 비트단위논리연산은 연산속도도 매우 우수하다.
 */
 
 const int Attack = 0x1;      // =     1 ( = 0001)
 const int Armor = 0x2;       // =    10 ( = 0010)
 const int HP = 0x4           // =   100 ( = 0100)
 const int MP = 0x8           // =  1000 
 const int Critical = 0x10    // = 10000 ( = 0001 0000)
 
 int Buf = 0; // 플래그
 
 /*
 예를들어 Attack, HP, Critical 의 버프를 받았다고 가정해보다.
 현재 Buf 값은 0이니까 0과 Attack(2진수)값인 1을 비교해보면
 Buf = 0 | 1 = 1
 */
 Buf = Buf | Attack; // Buf = 1 ( = 0001)
 //현재 Buf의 값이 (Buf | Attack 의 결과로) 1이니까
 Buf = Buf | HP; // Buf = 0101
 
 Buf = Buf | Critical; // 0101 | 10000 = 10101
 
 /*
 이미 켜진 것에 OR 연산해도 어차피 그대로 켜져있게 된다.
 OR연산을 이용해 우리가 원하는 비트를 켤 수 있다. 
 4바이트 변수 하나로 32가지를 켰다, 껐다 할 수 있다. 
 */
 
 // 어떤 버프를 받았는지 체크하려면 AND 연산을 사용하면 된다. 
 
 std::cout << "Buf는 : " << Buf << std::endl;
 // 10101 & 0001 = 00001. 0이 아닌 모든 수는 참. 해당 버프 받음.
 std::cout << "Attack : " << (Buf & Attack) << std::endl;
 // 10101 & 0010 = 0000. false 해당 버프 받지 않음.
 std::cout << "Armor : " << (Buf & Armor) << std::endl;
 // 10101 & 0100 = 00100 = true. 해당 버프 받음.
 std::cout << "HP : " << (Buf & HP) << std::endl;
 // 10101 & 01000 = 00000 = false 해당 버프 받지 않음.
 std::cout << "MP : " << (Buf & MP) << std::endl;
 // 10101 & 10000 = 10000 = true. 해당 버프 받음.
 std::cout << "Critical : " << (Buf & Critical) << std::endl;
 
 // Buf = Buf ^ Attack ^ HP ^ Critical; (각각 하나씩 연산해서 하나씩 꺼도 됨.)
 Buf = Buf ^ HP;
 std::cout << "HP : " << (Buf ^ HP) << std::endl; // HP만 꺼진 10001
 
 /*
 총 정리: OR 연산을 활용해 원하는 비트를 켰다 껐다 할 수 있음.
          AND 연산을 활용해 해당하는 비트가 채워졌는지 확인할 수 있음.
          XOR는 토글기능(스위치처럼 껐다 켰다 가능). XOR는 같으면 0, 다르면 1.
 */
 
 /*
 쉬프트 연산자 : << , >> 2가지 연산이 제공된다. cout, cin 과는 다름.
 
 10 << 2 연산을 위해서는 십진수 10의 값을 이진수로 바꿔야 한다.
 
 10 / 2 = 5 --- 0
 5 / 2 = 2 ---- 1
 2 / 2 = 1 ---- 0
 
 1010
 
 즉 1010 << 2 가 된다.
 << 2 라는 뜻은 << 왼쪽의 값을 2칸 이동시켜라. 즉, 우측에 0을 2개 붙이라는 뜻이다.
 그러므로 1010 << 2 = 101000 이 된다. 
 101000 을 십진수로 바꾸면
 
 1  0  1  0  0  0
 32 16 8  4  2  1
 
 결과값 : 40
 
 10 << 3 은
 1010 << 3 = 1010000
 
 결과값 : 80
 
 정리 : 2의 n승 단위의 곱은 빠르게 처리할 수 있다. 빠른곱셈이라고도 불린다.
 1010 << 2 = 10 * 2^2 와 같음. 3은 2^3과 같음.
 
 40 >> 2 연산을 해보자.
 101000 >> 2 와 같다. 반대 방향인 >> 은 오른쪽 자리 2개를 지워라 라는 의미와 같다.
 그래서 1010 이 된다. 
 결과값 : 10
 
 80 >> 3 = 
 1010000 >> 3 = 1010
 81 >> 3 = 1010 똑같다. (뒤의 2자리가 모두 사라지니까)
 
 >> 은 빠른나눗셈. 2의 n승 단위로 나눗셈 처리할 때 매우 빠르게 쓸 수 있다.
 
 총정리 : << 은 빠른 곱셈. 2의 n승 단위로 곱셈처리.
          >> 은 빠른 나눗셈. 2의 n승 단위로 나눗셈처리.
 */
 
 /*
 비트단위 논리연산자와 쉬프트 연산자를 활용해 RGB 컬러 조정하기.
 
 게임프로그래밍 중 화면에 나오는 컬러를 조정할 수 있어야 한다. 
 RGB 가 있는데 RGB 는 0 ~ 255까지의 색이며 unsigned char 사용 가능하다. 
 R : 0 ~ 255
 G : 0 ~ 255
 B : 0 ~ 255
 A : 0 ~ 255 (alpha. 투명도)
 
 A : 100
 R : 130
 G : 200
 B : 78
 
 이라는 색상이 있다고 해보자.
 
 int Color = 0;
 
 Color = 100; // 00000000 00000000 00000000 01100100 (01100100은 100의 이진법)
 Color = Color << 8; // 00000000 00000000 01100100 00000000 (0을 8개 추가)
 
 //   00000000 00000000 01100100 00000000
 // | 00000000 00000000 00000000 10000010
 // = 00000000 00000000 01100100 10000010
 Color = Color | 130; // 00000000 00000000 01100100 10000010
 
 Color << 8;
 //   00000000 01100100 10000010 00000000
 // | 00000000 00000000 00000000 11001000
 // = 00000000 01100100 10000010 11001000
 Color = Color | 200 // 00000000 01100100 10000010 11001000
 
 Color << 8;
 
 //   01100100 10000010 11001000 00000000
 // | 00000000 00000000 00000000 01001110
 // = 01100100 10000010 11001000 01001110
 Color = Color | 78
 
 std::cout << Color << std::endl;
 
 // 개별적으로 B값을 알고 싶으면 & 연산 사용.
 
 //   01100100 10000010 11001000 01001110
 // & 00000000 00000000 00000000 11111111
 // = 00000000 00000000 00000000 01001110
 std::cout << "B : " (Color & 0x000000ff) << std::endl;
 */
 
 int Number = 100;
 Number = Number + 10;
 
 Number += 10; // 위 2줄과 같은 의미
 
 
 
 
